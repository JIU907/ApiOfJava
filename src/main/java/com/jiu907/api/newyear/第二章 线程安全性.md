## 第二章 线程安全性

```
线程安全的核心在于要对状态访问操作进行管理，特别是共享和可变状态的访问
*共享意味着变量可以由多个线程同时访问
*可变代表着在对象的生命周期内是可变的
```

**确保变量安全的方式**

* 不再线程之间共享该状态的变量
* 使变量不可改变
* 在访问状态变量时使用同步

### 2.1什么是线程安全性

```
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的

无状态对象--
     不包含任何域
     不包含其他类中域的引用
     计算过程中的临时状态都保存在线程栈中的局部变量表
```

### 2.2原子性

* 竞态条件：由于不恰当的执行时序出现不正确的结果

```
比如对于一个不同变量进行并发累加，就大概率发生错误计算
* 因为value++: 是一个三阶段的操作，取值，累加，存值
```

**大多数竞态条件的本质**

```
基于一种可能失效的状态来做出判断或者执行某个操作(也就是先检查后执行)
```

**原子操作**

```
对于访问同一个状态的所有操作，这个操作是一个以原子方式执行的操作(所有的操作不可被打断)
```

### 2.3加锁机制

```
有时需要考虑并不仅仅是从变量的角度保证原子操作
而是从更大的维度去保证原子操作，例如缓存一致
```

**内置锁**

```
Synchronized(lock){}
同步代码块是java的内置锁，相当于一种互斥体，意味着最多只有一个线程能持有这把锁然后进行代码段内的操作
```

**重入锁**

```
内置锁是可以重入的
重入意味着获取锁的粒度是”线程“不是”调用“：同一个线程再次获取锁时，是允许获取的。进入退出同步代码块是相对应的+/-1
```

**变量同步与方法同步**

```
方法同步会出现遗忘，而且也不能保证数据安全
但是变量同步就可以保证数据安全

方法同步，由于加锁粗粒度，会导致性能降低，所以更多的时候可以考虑降低锁粒度(缩小缩同步代码块的范围)
```











