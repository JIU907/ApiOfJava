## 第四章 对象的组合

### 4.1设计线程安全的类

```
线程安全类的三要素

*：找出构造状态的所有变量
*：找出约束状态变量的不变性条件
*：建立对象状态的并发访问管理策略
```

**同步策略**

```
定义了
1.如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同
	*：后验性条件：例如线性递增的操作，后一个状态依赖前一个状态
	            那么操作必须得是一个复合操作
2.规定如何将不可变性，线程封闭与加锁机制等结合起来以维护线程安全性
```

**同步需求**

```
不变性条件：Integer.Max_Value
后验性条件：线形递增
约束多个状态的不变性条件: {
	1.例如一个对象中有2个字段，表示上限和下限
	2.具体数值不关心，但必须保证 上限>=下限
	3.这就必须保证对于2个值的操作必须处于一个原子操作
}
```

**依赖操作**

```
先验条件：例如在删除元素之前，队列必须不为空
        可以使用一些BlokingQueue
```

### 4.2 实例封闭

- 线程封闭：可以让这个对象只能由单个线程访问
- 锁：使用锁来保护该对象的所有访问

```
当一个对象封装到另一个对象时，能够访问被封装的对象的所有代码路径都是已知的
这要整个程序都能访问该对象的情况相比要容易分析

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持久正确的锁


```

**私有锁的问题**

```
Code: T03_PrivateLock
```

- 共有锁：也就是内置锁，也称之为类锁
- 私有锁：将对象内部的私有属性作为锁

*私有锁的好处*

```
1.私有的锁对象可以将锁封装起来，使客户代码无法访问到该锁(但可以通过共有方法访问到该锁)
2.如果客户代码错误的获得类另一个对象的锁，就有可能产生活跃性问题
3.想要验证某个公有访问的锁在程序中是否被正确使用，则需要检查整个程序

```

**监视器模式**

```
Code: T04_MonitorVehicleTracker
```

### 4.3 线程安全性的委托

```
通过多个"线程安全类组合的类是线程安全的"
```

**怎么样进行肆无忌惮的发布呢**

- 所有的状态变量是线程安全的
- 没有任何的不变性条件来约束它的值
- 在变量的操作上也不存在任何无效的值

- Code: T05_VisualComponent

### 4.4 在现有的线程安全类中添加功能

- 继承这个线程安全的类，实现自己的新逻辑
    - 问题就是，如果这个类的同步状态是封装的不可继承的，怎么办？
- 在源码中添加--想想吧就
- 客户端代码加锁机制
    - 要注意对象锁和客户端锁是不是同一把，不然也是徒劳

```
客户端代码加锁与继承锁的方式其实本质上都将加锁逻辑进行了分离，这一定程度上会导致其他的不承诺加锁的类上使用的客户端加锁时，要特别的小心
```

**组合**

Code：T08_ImprovedList




