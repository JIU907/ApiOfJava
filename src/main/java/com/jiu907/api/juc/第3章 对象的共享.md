## 第三章 对象的共享

```
Synchronized的作用并不局限于代码块的原子操作，内存可见性也是其重要作用之一
```

### 3.1 可见性

```
多线程环境下，读线程未必就能及时的发现写线程的操作。
结合JMM可知，高速缓存区刷写会主内存是存在时间差的
```

**失效值**

```
一个线程获取到该变量的最新值
另一个线程可能获取到该变量的就值

这问题的根源是在对值的操作或者代码块的非原子操作上
较先读取的未必就能及时的进行操作(考虑到操作系统对线程所分配的cpu执行时间片)
```

**非原子的64位操作**

```
非volatile修饰的共享变量
JMM要求--
变量的读取操作和写入操作都必须时原子操作
但是对于long和double这种64位变量，JVM允许将读写操作分解为2个32位操作
 这就导致了程序很有可能操作的是一个随机数，而不是我们曾经设置的一个数
```

**加锁与可见性**

```
代码段如果是一个同步操作
那么先执行的线程A的所有操作结果都能够被线程B所感知
```

**volatile变量**

```
Java提供了一种较弱的同步机制--volatile变量
可以将变量的更新操作通知到其他线程，也禁止了指令的重排序
读取volatile类型的变量时总会返回最新写入的值
```

* 可见性
* 禁止指令重排序
* 不保证原子性：volatile起到的是通知作用，而不是原子操作

### 3.2发布与逸出

- 发布：使对象能够在当前作用域之外的代码中使用
    - 例如，通过共有方法得到私有属性
    - 例如，通过共有属性获取其他私有属性
- 逸出：不应该被发布的对象被发布时