## 第三章 对象的共享

```
Synchronized的作用并不局限于代码块的原子操作，内存可见性也是其重要作用之一
```

### 3.1 可见性

```
多线程环境下，读线程未必就能及时的发现写线程的操作。
结合JMM可知，高速缓存区刷写会主内存是存在时间差的
```

**失效值**

```
一个线程获取到该变量的最新值
另一个线程可能获取到该变量的就值

这问题的根源是在对值的操作或者代码块的非原子操作上
较先读取的未必就能及时的进行操作(考虑到操作系统对线程所分配的cpu执行时间片)
```

**非原子的64位操作**

```
非volatile修饰的共享变量
JMM要求--
变量的读取操作和写入操作都必须时原子操作
但是对于long和double这种64位变量，JVM允许将读写操作分解为2个32位操作
 这就导致了程序很有可能操作的是一个随机数，而不是我们曾经设置的一个数
```

**加锁与可见性**

```
代码段如果是一个同步操作
那么先执行的线程A的所有操作结果都能够被线程B所感知
```

**volatile变量**

```
Java提供了一种较弱的同步机制--volatile变量
可以将变量的更新操作通知到其他线程，也禁止了指令的重排序
读取volatile类型的变量时总会返回最新写入的值
```

* 可见性
* 禁止指令重排序
* 不保证原子性：volatile起到的是通知作用，而不是原子操作

### 3.2发布与逸出

- 发布：使对象能够在当前作用域之外的代码中使用
    - 例如，通过共有方法得到私有属性
    - 例如，通过共有属性获取其他私有属性
- 逸出：不应该被发布的对象被发布时

### 3.3线程封闭

```
将某个对象封闭在一个线程中，就类似于单线程的情况，就称之为线程封闭
```

**Ad-hoc线程**

```
维护线程封闭性的职责完全由程序自己实现
```

**栈封闭**

demo：T04_StackClosed

```
将变量以局部变量的方式进行操作

因为局部变量的固有属性就是封闭在执行线程中，其他线程无法访问到该线程的局部变量表
```

**ThreadLocal类**

```
使线程中的某个值与保存值关联起来

通过get()/set()为使用该变量的线程都保存一份独立的副本

典型的案例就是Spring的事务引导中使用ThreadLoacl来保存Connection，分支一次调用中所使用的Connection不一致
```

### 3.4不变性

```
不可变对象是指该对象一经构造其状态便不会被改变

被fianl修饰的一定是不可变变量吗？例如
1.User对象内含有Address对象的引用
2.即使User对象被final修饰，但是其内部字段Address对象仍然会被改变

什么是不可变对象
1.对象创建以后状态不能被修改
2.对象的所有域都是final类型
3.对象是正确创建的，也就是对象在创建期间，this引用没有被逸出
```

### 3.5安全发布

demo: T05_UnSafePublish

```
非同步的常规get set方法其实是存在安全问题的

不同线程操作同一个对象的同一个属性，那就会导致不同线程看到相同对象的属性是不一致的
```

**安全发布的方式**

```
1.在静态初始化函数中初始化一个对象的引用
2.将对象保存在一个由volatile修饰的AtomicReferance对象中
  代表：线程可见，原子操作
3.将对的引用保存在某个正确构造对象的final类型域中
	这个对象的所有字段都是final，那么这个对象是不可变对象
4.将对象保存在一个由锁保护的域中
	eg: HashTable -> 线程安全的容器，那么通过这个容器操作对象都是安全的
```

**事实不可变对象**

```
释义： 技术上可变，但业务上不再变的对象

例如：将<userID,firstLoginDate>存入HashMap中
```

**可变对象**

```
如果对象在构造之后可以修改，那么也就只能确保当时发布时的状态可见性

要想共享可变对象
1.需要安全发布
2.访问和修改操作需要同步
```

### 总结

- 线程封闭：线程封闭的对象只能由一个线程独有
- 只读共享：不可变对象和事实不可变对象
- 线程安全共享：线程安全的对象在其内部实现同步，例如，同步容器，hash Table
- 保护对象：通过持久特定的锁进行访问，比如想要读写对象的值，就需要调用对应的同步方法

