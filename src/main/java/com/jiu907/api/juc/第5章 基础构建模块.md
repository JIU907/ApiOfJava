## 第五章 基础构建模块

```
将线程安全性交给线程安全类
*：一个线程的执行过程中，所操作的对象如果是线程安全类的对象，那就不存在线程安全问题
```

### 5.1 同步安全容器

```
*：使用同步安全容器，重要的地方在于，当操作这个容器时是线程安全的
   但是这个容器内的对象未必是安全的
*：使用这种方式只能保证通过该容器操作内部对象是线程安全
   即每次只有一个线程能访问该容器的状态
```

**同步安全容器的问题**

```
复合操作下，线程安全，但并不是想要的结果
Code: T01_SynchronizedContainerQuestion
```

### 5.2 并发容器

- 同步容器：将所有对容器状态的访问都进行串行化操作
    - 高安全性，低并发性
- 并发容器：针对多个线程并发访问进行的操作
    - 在保证安全性的情况下，提高并发性

**ConcurrentHashMap**

- HashTable与synchronized中对容器的状态访问会进行申请独占锁
- ConcurrentHashMap是使用分段锁进行控制，粒度更小
    - 参见11.4.3节
- ConcurrentHashMap的迭代器，可以(不是保证！)在迭代器被构造后将修改操作反映给容器

**CopyOnWriteArrayList**

- 用来替代同步的List，提供了更好的同步性
    - add时，加同步代码块锁，获取当前数组的副本，设置新值后保存副本
    - get时，返回最新的元素数组副本

### 5.3 阻塞队列和生产者-消费者模式

```
阻塞队列可以支持生产者-消费者这种模式
```

**生产者-消费者模式**

- 这种方式利于简化开发流程，将生产者与消费者的代码依赖性解除，虽然还是通过阻塞队列耦合在一起
- 这种方式让程序设计更为简单，接口职能设计更加单一
    - 其中的某一方只关注自己的业务逻辑，并不需要考虑另外一方的逻辑
- 特别是当一方为IO密集型，另一方为CPU密集型时优势更加明显
    - 整个流程不再强烈的局限于IO密集型的处理速度(IO密集型的操作是耗时的)


